//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.2.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

export interface IFuseApiClient {

    /**
     * @return OK
     */
    accountAll(signal?: AbortSignal): Promise<Account[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    accountPOST(body: CreateAccount | undefined, signal?: AbortSignal): Promise<Account>;

    /**
     * @return OK
     */
    accountGET(id: string, signal?: AbortSignal): Promise<Account>;

    /**
     * @param body (optional) 
     * @return OK
     */
    accountPUT(id: string, body: UpdateAccount | undefined, signal?: AbortSignal): Promise<Account>;

    /**
     * @return No Content
     */
    accountDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    grantPOST(accountId: string, body: CreateAccountGrant | undefined, signal?: AbortSignal): Promise<Grant>;

    /**
     * @param body (optional) 
     * @return OK
     */
    grantPUT(accountId: string, grantId: string, body: UpdateAccountGrant | undefined, signal?: AbortSignal): Promise<Grant>;

    /**
     * @return No Content
     */
    grantDELETE(accountId: string, grantId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    applicationAll(signal?: AbortSignal): Promise<Application[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    applicationPOST(body: CreateApplication | undefined, signal?: AbortSignal): Promise<Application>;

    /**
     * @return OK
     */
    applicationGET(id: string, signal?: AbortSignal): Promise<Application>;

    /**
     * @param body (optional) 
     * @return OK
     */
    applicationPUT(id: string, body: UpdateApplication | undefined, signal?: AbortSignal): Promise<Application>;

    /**
     * @return No Content
     */
    applicationDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    instancesPOST(appId: string, body: CreateApplicationInstance | undefined, signal?: AbortSignal): Promise<ApplicationInstance>;

    /**
     * @param body (optional) 
     * @return OK
     */
    instancesPUT(appId: string, instanceId: string, body: UpdateApplicationInstance | undefined, signal?: AbortSignal): Promise<ApplicationInstance>;

    /**
     * @return No Content
     */
    instancesDELETE(appId: string, instanceId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    pipelinesPOST(appId: string, body: CreateApplicationPipeline | undefined, signal?: AbortSignal): Promise<ApplicationPipeline>;

    /**
     * @param body (optional) 
     * @return OK
     */
    pipelinesPUT(appId: string, pipelineId: string, body: UpdateApplicationPipeline | undefined, signal?: AbortSignal): Promise<ApplicationPipeline>;

    /**
     * @return No Content
     */
    pipelinesDELETE(appId: string, pipelineId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return Created
     */
    dependenciesPOST(appId: string, instanceId: string, body: CreateApplicationDependency | undefined, signal?: AbortSignal): Promise<ApplicationInstanceDependency>;

    /**
     * @param body (optional) 
     * @return OK
     */
    dependenciesPUT(appId: string, instanceId: string, dependencyId: string, body: UpdateApplicationDependency | undefined, signal?: AbortSignal): Promise<ApplicationInstanceDependency>;

    /**
     * @return No Content
     */
    dependenciesDELETE(appId: string, instanceId: string, dependencyId: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param format (optional) 
     * @return OK
     */
    export(format: string | undefined, signal?: AbortSignal): Promise<FileResponse>;

    /**
     * @param format (optional) 
     * @return OK
     */
    template(format: string | undefined, signal?: AbortSignal): Promise<FileResponse>;

    /**
     * @param format (optional) 
     * @param file (optional) 
     * @return OK
     */
    import(format: string | undefined, file: FileParameter | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    dataStoreAll(signal?: AbortSignal): Promise<DataStore[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    dataStorePOST(body: CreateDataStore | undefined, signal?: AbortSignal): Promise<DataStore>;

    /**
     * @return OK
     */
    dataStoreGET(id: string, signal?: AbortSignal): Promise<DataStore>;

    /**
     * @param body (optional) 
     * @return OK
     */
    dataStorePUT(id: string, body: UpdateDataStore | undefined, signal?: AbortSignal): Promise<DataStore>;

    /**
     * @return No Content
     */
    dataStoreDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    environmentAll(signal?: AbortSignal): Promise<EnvironmentInfo[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    environmentPOST(body: CreateEnvironment | undefined, signal?: AbortSignal): Promise<EnvironmentInfo>;

    /**
     * @param body (optional) 
     * @return OK
     */
    environmentPUT(id: string, body: UpdateEnvironment | undefined, signal?: AbortSignal): Promise<EnvironmentInfo>;

    /**
     * @return No Content
     */
    environmentDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    environmentApplyAutomationPOST(body: ApplyEnvironmentAutomation | undefined, signal?: AbortSignal): Promise<number>;

    /**
     * @return OK
     */
    externalResourceAll(signal?: AbortSignal): Promise<ExternalResource[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    externalResourcePOST(body: CreateExternalResource | undefined, signal?: AbortSignal): Promise<ExternalResource>;

    /**
     * @return OK
     */
    externalResourceGET(id: string, signal?: AbortSignal): Promise<ExternalResource>;

    /**
     * @param body (optional) 
     * @return OK
     */
    externalResourcePUT(id: string, body: UpdateExternalResource | undefined, signal?: AbortSignal): Promise<ExternalResource>;

    /**
     * @return No Content
     */
    externalResourceDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    kumaIntegrationAll(signal?: AbortSignal): Promise<KumaIntegrationResponse[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    kumaIntegrationPOST(body: CreateKumaIntegration | undefined, signal?: AbortSignal): Promise<KumaIntegrationResponse>;

    /**
     * @return OK
     */
    kumaIntegrationGET(id: string, signal?: AbortSignal): Promise<KumaIntegrationResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    kumaIntegrationPUT(id: string, body: UpdateKumaIntegration | undefined, signal?: AbortSignal): Promise<KumaIntegrationResponse>;

    /**
     * @return No Content
     */
    kumaIntegrationDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    platformAll(signal?: AbortSignal): Promise<Platform[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    platformPOST(body: CreatePlatform | undefined, signal?: AbortSignal): Promise<Platform>;

    /**
     * @return OK
     */
    platformGET(id: string, signal?: AbortSignal): Promise<Platform>;

    /**
     * @param body (optional) 
     * @return OK
     */
    platformPUT(id: string, body: UpdatePlatform | undefined, signal?: AbortSignal): Promise<Platform>;

    /**
     * @return No Content
     */
    platformDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    state(signal?: AbortSignal): Promise<SecurityStateResponse>;

    /**
     * @param body (optional) 
     * @return OK
     */
    settings(body: UpdateSecuritySettings | undefined, signal?: AbortSignal): Promise<SecuritySettings>;

    /**
     * @param body (optional) 
     * @return Created
     */
    accountsPOST(body: CreateSecurityUser | undefined, signal?: AbortSignal): Promise<SecurityUserInfo>;

    /**
     * @return OK
     */
    accountsAll(signal?: AbortSignal): Promise<SecurityUserResponse[]>;

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginSecurityUser | undefined, signal?: AbortSignal): Promise<LoginSession>;

    /**
     * @param body (optional) 
     * @return No Content
     */
    logout(body: LogoutSecurityUser | undefined, signal?: AbortSignal): Promise<void>;

    /**
     * @param body (optional) 
     * @return OK
     */
    accountsPATCH(id: string, body: UpdateUser | undefined, signal?: AbortSignal): Promise<SecurityUserResponse>;

    /**
     * @return No Content
     */
    accountsDELETE(id: string, signal?: AbortSignal): Promise<void>;

    /**
     * @return OK
     */
    tagAll(signal?: AbortSignal): Promise<Tag[]>;

    /**
     * @param body (optional) 
     * @return Created
     */
    tagPOST(body: CreateTag | undefined, signal?: AbortSignal): Promise<Tag>;

    /**
     * @return OK
     */
    tagGET(id: string, signal?: AbortSignal): Promise<Tag>;

    /**
     * @param body (optional) 
     * @return OK
     */
    tagPUT(id: string, body: UpdateTag | undefined, signal?: AbortSignal): Promise<Tag>;

    /**
     * @return No Content
     */
    tagDELETE(id: string, signal?: AbortSignal): Promise<void>;
}

export class FuseApiClient implements IFuseApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return OK
     */
    accountAll(signal?: AbortSignal): Promise<Account[]> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountAll(_response);
        });
    }

    protected processAccountAll(response: Response): Promise<Account[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Account.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    accountPOST(body: CreateAccount | undefined, signal?: AbortSignal): Promise<Account> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountPOST(_response);
        });
    }

    protected processAccountPOST(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Account.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * @return OK
     */
    accountGET(id: string, signal?: AbortSignal): Promise<Account> {
        let url_ = this.baseUrl + "/api/Account/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountGET(_response);
        });
    }

    protected processAccountGET(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    accountPUT(id: string, body: UpdateAccount | undefined, signal?: AbortSignal): Promise<Account> {
        let url_ = this.baseUrl + "/api/Account/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountPUT(_response);
        });
    }

    protected processAccountPUT(response: Response): Promise<Account> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Account>(null as any);
    }

    /**
     * @return No Content
     */
    accountDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountDELETE(_response);
        });
    }

    protected processAccountDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    grantPOST(accountId: string, body: CreateAccountGrant | undefined, signal?: AbortSignal): Promise<Grant> {
        let url_ = this.baseUrl + "/api/Account/{accountId}/grant";
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantPOST(_response);
        });
    }

    protected processGrantPOST(response: Response): Promise<Grant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Grant.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Grant>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    grantPUT(accountId: string, grantId: string, body: UpdateAccountGrant | undefined, signal?: AbortSignal): Promise<Grant> {
        let url_ = this.baseUrl + "/api/Account/{accountId}/grant/{grantId}";
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        if (grantId === undefined || grantId === null)
            throw new globalThis.Error("The parameter 'grantId' must be defined.");
        url_ = url_.replace("{grantId}", encodeURIComponent("" + grantId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantPUT(_response);
        });
    }

    protected processGrantPUT(response: Response): Promise<Grant> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Grant.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Grant>(null as any);
    }

    /**
     * @return No Content
     */
    grantDELETE(accountId: string, grantId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Account/{accountId}/grant/{grantId}";
        if (accountId === undefined || accountId === null)
            throw new globalThis.Error("The parameter 'accountId' must be defined.");
        url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
        if (grantId === undefined || grantId === null)
            throw new globalThis.Error("The parameter 'grantId' must be defined.");
        url_ = url_.replace("{grantId}", encodeURIComponent("" + grantId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGrantDELETE(_response);
        });
    }

    protected processGrantDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    applicationAll(signal?: AbortSignal): Promise<Application[]> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationAll(_response);
        });
    }

    protected processApplicationAll(response: Response): Promise<Application[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Application.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    applicationPOST(body: CreateApplication | undefined, signal?: AbortSignal): Promise<Application> {
        let url_ = this.baseUrl + "/api/Application";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationPOST(_response);
        });
    }

    protected processApplicationPOST(response: Response): Promise<Application> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Application.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application>(null as any);
    }

    /**
     * @return OK
     */
    applicationGET(id: string, signal?: AbortSignal): Promise<Application> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationGET(_response);
        });
    }

    protected processApplicationGET(response: Response): Promise<Application> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Application.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    applicationPUT(id: string, body: UpdateApplication | undefined, signal?: AbortSignal): Promise<Application> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationPUT(_response);
        });
    }

    protected processApplicationPUT(response: Response): Promise<Application> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Application.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Application>(null as any);
    }

    /**
     * @return No Content
     */
    applicationDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processApplicationDELETE(_response);
        });
    }

    protected processApplicationDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    instancesPOST(appId: string, body: CreateApplicationInstance | undefined, signal?: AbortSignal): Promise<ApplicationInstance> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesPOST(_response);
        });
    }

    protected processInstancesPOST(response: Response): Promise<ApplicationInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicationInstance.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInstance>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    instancesPUT(appId: string, instanceId: string, body: UpdateApplicationInstance | undefined, signal?: AbortSignal): Promise<ApplicationInstance> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesPUT(_response);
        });
    }

    protected processInstancesPUT(response: Response): Promise<ApplicationInstance> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationInstance.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInstance>(null as any);
    }

    /**
     * @return No Content
     */
    instancesDELETE(appId: string, instanceId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processInstancesDELETE(_response);
        });
    }

    protected processInstancesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    pipelinesPOST(appId: string, body: CreateApplicationPipeline | undefined, signal?: AbortSignal): Promise<ApplicationPipeline> {
        let url_ = this.baseUrl + "/api/Application/{appId}/pipelines";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPipelinesPOST(_response);
        });
    }

    protected processPipelinesPOST(response: Response): Promise<ApplicationPipeline> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicationPipeline.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationPipeline>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    pipelinesPUT(appId: string, pipelineId: string, body: UpdateApplicationPipeline | undefined, signal?: AbortSignal): Promise<ApplicationPipeline> {
        let url_ = this.baseUrl + "/api/Application/{appId}/pipelines/{pipelineId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (pipelineId === undefined || pipelineId === null)
            throw new globalThis.Error("The parameter 'pipelineId' must be defined.");
        url_ = url_.replace("{pipelineId}", encodeURIComponent("" + pipelineId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPipelinesPUT(_response);
        });
    }

    protected processPipelinesPUT(response: Response): Promise<ApplicationPipeline> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationPipeline.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationPipeline>(null as any);
    }

    /**
     * @return No Content
     */
    pipelinesDELETE(appId: string, pipelineId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/{appId}/pipelines/{pipelineId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (pipelineId === undefined || pipelineId === null)
            throw new globalThis.Error("The parameter 'pipelineId' must be defined.");
        url_ = url_.replace("{pipelineId}", encodeURIComponent("" + pipelineId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPipelinesDELETE(_response);
        });
    }

    protected processPipelinesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    dependenciesPOST(appId: string, instanceId: string, body: CreateApplicationDependency | undefined, signal?: AbortSignal): Promise<ApplicationInstanceDependency> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}/dependencies";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDependenciesPOST(_response);
        });
    }

    protected processDependenciesPOST(response: Response): Promise<ApplicationInstanceDependency> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicationInstanceDependency.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInstanceDependency>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dependenciesPUT(appId: string, instanceId: string, dependencyId: string, body: UpdateApplicationDependency | undefined, signal?: AbortSignal): Promise<ApplicationInstanceDependency> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}/dependencies/{dependencyId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        if (dependencyId === undefined || dependencyId === null)
            throw new globalThis.Error("The parameter 'dependencyId' must be defined.");
        url_ = url_.replace("{dependencyId}", encodeURIComponent("" + dependencyId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDependenciesPUT(_response);
        });
    }

    protected processDependenciesPUT(response: Response): Promise<ApplicationInstanceDependency> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationInstanceDependency.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ApplicationInstanceDependency>(null as any);
    }

    /**
     * @return No Content
     */
    dependenciesDELETE(appId: string, instanceId: string, dependencyId: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Application/{appId}/instances/{instanceId}/dependencies/{dependencyId}";
        if (appId === undefined || appId === null)
            throw new globalThis.Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (instanceId === undefined || instanceId === null)
            throw new globalThis.Error("The parameter 'instanceId' must be defined.");
        url_ = url_.replace("{instanceId}", encodeURIComponent("" + instanceId));
        if (dependencyId === undefined || dependencyId === null)
            throw new globalThis.Error("The parameter 'dependencyId' must be defined.");
        url_ = url_.replace("{dependencyId}", encodeURIComponent("" + dependencyId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDependenciesDELETE(_response);
        });
    }

    protected processDependenciesDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param format (optional) 
     * @return OK
     */
    export(format: string | undefined, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Config/export?";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExport(_response);
        });
    }

    protected processExport(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param format (optional) 
     * @return OK
     */
    template(format: string | undefined, signal?: AbortSignal): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Config/template?";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTemplate(_response);
        });
    }

    protected processTemplate(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    /**
     * @param format (optional) 
     * @param file (optional) 
     * @return OK
     */
    import(format: string | undefined, file: FileParameter | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Config/import?";
        if (format === null)
            throw new globalThis.Error("The parameter 'format' cannot be null.");
        else if (format !== undefined)
            url_ += "format=" + encodeURIComponent("" + format) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new globalThis.Error("The parameter 'file' cannot be null.");
        else
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processImport(_response);
        });
    }

    protected processImport(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    dataStoreAll(signal?: AbortSignal): Promise<DataStore[]> {
        let url_ = this.baseUrl + "/api/DataStore";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStoreAll(_response);
        });
    }

    protected processDataStoreAll(response: Response): Promise<DataStore[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DataStore.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataStore[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    dataStorePOST(body: CreateDataStore | undefined, signal?: AbortSignal): Promise<DataStore> {
        let url_ = this.baseUrl + "/api/DataStore";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStorePOST(_response);
        });
    }

    protected processDataStorePOST(response: Response): Promise<DataStore> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DataStore.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataStore>(null as any);
    }

    /**
     * @return OK
     */
    dataStoreGET(id: string, signal?: AbortSignal): Promise<DataStore> {
        let url_ = this.baseUrl + "/api/DataStore/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStoreGET(_response);
        });
    }

    protected processDataStoreGET(response: Response): Promise<DataStore> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataStore.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataStore>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    dataStorePUT(id: string, body: UpdateDataStore | undefined, signal?: AbortSignal): Promise<DataStore> {
        let url_ = this.baseUrl + "/api/DataStore/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStorePUT(_response);
        });
    }

    protected processDataStorePUT(response: Response): Promise<DataStore> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataStore.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataStore>(null as any);
    }

    /**
     * @return No Content
     */
    dataStoreDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/DataStore/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processDataStoreDELETE(_response);
        });
    }

    protected processDataStoreDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    environmentAll(signal?: AbortSignal): Promise<EnvironmentInfo[]> {
        let url_ = this.baseUrl + "/api/Environment";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentAll(_response);
        });
    }

    protected processEnvironmentAll(response: Response): Promise<EnvironmentInfo[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EnvironmentInfo.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnvironmentInfo[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    environmentPOST(body: CreateEnvironment | undefined, signal?: AbortSignal): Promise<EnvironmentInfo> {
        let url_ = this.baseUrl + "/api/Environment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentPOST(_response);
        });
    }

    protected processEnvironmentPOST(response: Response): Promise<EnvironmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EnvironmentInfo.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnvironmentInfo>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    environmentPUT(id: string, body: UpdateEnvironment | undefined, signal?: AbortSignal): Promise<EnvironmentInfo> {
        let url_ = this.baseUrl + "/api/Environment/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentPUT(_response);
        });
    }

    protected processEnvironmentPUT(response: Response): Promise<EnvironmentInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EnvironmentInfo.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EnvironmentInfo>(null as any);
    }

    /**
     * @return No Content
     */
    environmentDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Environment/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentDELETE(_response);
        });
    }

    protected processEnvironmentDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    environmentApplyAutomationPOST(body: ApplyEnvironmentAutomation | undefined, signal?: AbortSignal): Promise<number> {
        let url_ = this.baseUrl + "/api/Environment/apply-automation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processEnvironmentApplyAutomationPOST(_response);
        });
    }

    protected processEnvironmentApplyAutomationPOST(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200.instancesCreated : null as any;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    /**
     * @return OK
     */
    externalResourceAll(signal?: AbortSignal): Promise<ExternalResource[]> {
        let url_ = this.baseUrl + "/api/ExternalResource";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourceAll(_response);
        });
    }

    protected processExternalResourceAll(response: Response): Promise<ExternalResource[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalResource.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalResource[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    externalResourcePOST(body: CreateExternalResource | undefined, signal?: AbortSignal): Promise<ExternalResource> {
        let url_ = this.baseUrl + "/api/ExternalResource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourcePOST(_response);
        });
    }

    protected processExternalResourcePOST(response: Response): Promise<ExternalResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ExternalResource.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalResource>(null as any);
    }

    /**
     * @return OK
     */
    externalResourceGET(id: string, signal?: AbortSignal): Promise<ExternalResource> {
        let url_ = this.baseUrl + "/api/ExternalResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourceGET(_response);
        });
    }

    protected processExternalResourceGET(response: Response): Promise<ExternalResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalResource.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalResource>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    externalResourcePUT(id: string, body: UpdateExternalResource | undefined, signal?: AbortSignal): Promise<ExternalResource> {
        let url_ = this.baseUrl + "/api/ExternalResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourcePUT(_response);
        });
    }

    protected processExternalResourcePUT(response: Response): Promise<ExternalResource> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalResource.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExternalResource>(null as any);
    }

    /**
     * @return No Content
     */
    externalResourceDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/ExternalResource/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExternalResourceDELETE(_response);
        });
    }

    protected processExternalResourceDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    kumaIntegrationAll(signal?: AbortSignal): Promise<KumaIntegrationResponse[]> {
        let url_ = this.baseUrl + "/api/KumaIntegration";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationAll(_response);
        });
    }

    protected processKumaIntegrationAll(response: Response): Promise<KumaIntegrationResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(KumaIntegrationResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KumaIntegrationResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    kumaIntegrationPOST(body: CreateKumaIntegration | undefined, signal?: AbortSignal): Promise<KumaIntegrationResponse> {
        let url_ = this.baseUrl + "/api/KumaIntegration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationPOST(_response);
        });
    }

    protected processKumaIntegrationPOST(response: Response): Promise<KumaIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = KumaIntegrationResponse.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KumaIntegrationResponse>(null as any);
    }

    /**
     * @return OK
     */
    kumaIntegrationGET(id: string, signal?: AbortSignal): Promise<KumaIntegrationResponse> {
        let url_ = this.baseUrl + "/api/KumaIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationGET(_response);
        });
    }

    protected processKumaIntegrationGET(response: Response): Promise<KumaIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KumaIntegrationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KumaIntegrationResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    kumaIntegrationPUT(id: string, body: UpdateKumaIntegration | undefined, signal?: AbortSignal): Promise<KumaIntegrationResponse> {
        let url_ = this.baseUrl + "/api/KumaIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationPUT(_response);
        });
    }

    protected processKumaIntegrationPUT(response: Response): Promise<KumaIntegrationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KumaIntegrationResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KumaIntegrationResponse>(null as any);
    }

    /**
     * @return No Content
     */
    kumaIntegrationDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/KumaIntegration/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processKumaIntegrationDELETE(_response);
        });
    }

    protected processKumaIntegrationDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    platformAll(signal?: AbortSignal): Promise<Platform[]> {
        let url_ = this.baseUrl + "/api/Platform";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformAll(_response);
        });
    }

    protected processPlatformAll(response: Response): Promise<Platform[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Platform.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Platform[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    platformPOST(body: CreatePlatform | undefined, signal?: AbortSignal): Promise<Platform> {
        let url_ = this.baseUrl + "/api/Platform";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformPOST(_response);
        });
    }

    protected processPlatformPOST(response: Response): Promise<Platform> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Platform.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Platform>(null as any);
    }

    /**
     * @return OK
     */
    platformGET(id: string, signal?: AbortSignal): Promise<Platform> {
        let url_ = this.baseUrl + "/api/Platform/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformGET(_response);
        });
    }

    protected processPlatformGET(response: Response): Promise<Platform> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Platform.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Platform>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    platformPUT(id: string, body: UpdatePlatform | undefined, signal?: AbortSignal): Promise<Platform> {
        let url_ = this.baseUrl + "/api/Platform/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformPUT(_response);
        });
    }

    protected processPlatformPUT(response: Response): Promise<Platform> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Platform.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Platform>(null as any);
    }

    /**
     * @return No Content
     */
    platformDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Platform/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPlatformDELETE(_response);
        });
    }

    protected processPlatformDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    state(signal?: AbortSignal): Promise<SecurityStateResponse> {
        let url_ = this.baseUrl + "/api/Security/state";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processState(_response);
        });
    }

    protected processState(response: Response): Promise<SecurityStateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityStateResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityStateResponse>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    settings(body: UpdateSecuritySettings | undefined, signal?: AbortSignal): Promise<SecuritySettings> {
        let url_ = this.baseUrl + "/api/Security/settings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSettings(_response);
        });
    }

    protected processSettings(response: Response): Promise<SecuritySettings> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecuritySettings.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecuritySettings>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    accountsPOST(body: CreateSecurityUser | undefined, signal?: AbortSignal): Promise<SecurityUserInfo> {
        let url_ = this.baseUrl + "/api/Security/accounts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountsPOST(_response);
        });
    }

    protected processAccountsPOST(response: Response): Promise<SecurityUserInfo> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SecurityUserInfo.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status === 403) {
            return response.text().then((_responseText) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("Forbidden", status, _responseText, _headers, result403);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityUserInfo>(null as any);
    }

    /**
     * @return OK
     */
    accountsAll(signal?: AbortSignal): Promise<SecurityUserResponse[]> {
        let url_ = this.baseUrl + "/api/Security/accounts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountsAll(_response);
        });
    }

    protected processAccountsAll(response: Response): Promise<SecurityUserResponse[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SecurityUserResponse.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityUserResponse[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    login(body: LoginSecurityUser | undefined, signal?: AbortSignal): Promise<LoginSession> {
        let url_ = this.baseUrl + "/api/Security/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<LoginSession> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginSession.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 401) {
            return response.text().then((_responseText) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("Unauthorized", status, _responseText, _headers, result401);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginSession>(null as any);
    }

    /**
     * @param body (optional) 
     * @return No Content
     */
    logout(body: LogoutSecurityUser | undefined, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Security/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    accountsPATCH(id: string, body: UpdateUser | undefined, signal?: AbortSignal): Promise<SecurityUserResponse> {
        let url_ = this.baseUrl + "/api/Security/accounts/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PATCH",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountsPATCH(_response);
        });
    }

    protected processAccountsPATCH(response: Response): Promise<SecurityUserResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SecurityUserResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SecurityUserResponse>(null as any);
    }

    /**
     * @return No Content
     */
    accountsDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Security/accounts/{Id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processAccountsDELETE(_response);
        });
    }

    protected processAccountsDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @return OK
     */
    tagAll(signal?: AbortSignal): Promise<Tag[]> {
        let url_ = this.baseUrl + "/api/Tag";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagAll(_response);
        });
    }

    protected processTagAll(response: Response): Promise<Tag[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Tag.fromJS(item));
            }
            else {
                result200 = null as any;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tag[]>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Created
     */
    tagPOST(body: CreateTag | undefined, signal?: AbortSignal): Promise<Tag> {
        let url_ = this.baseUrl + "/api/Tag";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagPOST(_response);
        });
    }

    protected processTagPOST(response: Response): Promise<Tag> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 201) {
            return response.text().then((_responseText) => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Tag.fromJS(resultData201);
            return result201;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @return OK
     */
    tagGET(id: string, signal?: AbortSignal): Promise<Tag> {
        let url_ = this.baseUrl + "/api/Tag/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagGET(_response);
        });
    }

    protected processTagGET(response: Response): Promise<Tag> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tag.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @param body (optional) 
     * @return OK
     */
    tagPUT(id: string, body: UpdateTag | undefined, signal?: AbortSignal): Promise<Tag> {
        let url_ = this.baseUrl + "/api/Tag/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagPUT(_response);
        });
    }

    protected processTagPUT(response: Response): Promise<Tag> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Tag.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("Bad Request", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status === 409) {
            return response.text().then((_responseText) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("Conflict", status, _responseText, _headers, result409);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Tag>(null as any);
    }

    /**
     * @return No Content
     */
    tagDELETE(id: string, signal?: AbortSignal): Promise<void> {
        let url_ = this.baseUrl + "/api/Tag/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processTagDELETE(_response);
        });
    }

    protected processTagDELETE(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 204) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("Not Found", status, _responseText, _headers, result404);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class Account implements IAccount {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretRef?: string | undefined;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.authKind = _data["AuthKind"];
            this.secretRef = _data["SecretRef"];
            this.userName = _data["UserName"];
            if (_data["Parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["Parameters"]) {
                    if (_data["Parameters"].hasOwnProperty(key))
                        (this.parameters as any)![key] = _data["Parameters"][key];
                }
            }
            if (Array.isArray(_data["Grants"])) {
                this.grants = [] as any;
                for (let item of _data["Grants"])
                    this.grants!.push(Grant.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["AuthKind"] = this.authKind;
        data["SecretRef"] = this.secretRef;
        data["UserName"] = this.userName;
        if (this.parameters) {
            data["Parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (data["Parameters"] as any)[key] = (this.parameters as any)[key];
            }
        }
        if (Array.isArray(this.grants)) {
            data["Grants"] = [];
            for (let item of this.grants)
                data["Grants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IAccount {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretRef?: string | undefined;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class Application implements IApplication {
    id?: string;
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    tagIds?: string[] | undefined;
    instances?: ApplicationInstance[] | undefined;
    pipelines?: ApplicationPipeline[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.version = _data["Version"];
            this.description = _data["Description"];
            this.owner = _data["Owner"];
            this.notes = _data["Notes"];
            this.framework = _data["Framework"];
            this.repositoryUri = _data["RepositoryUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            if (Array.isArray(_data["Instances"])) {
                this.instances = [] as any;
                for (let item of _data["Instances"])
                    this.instances!.push(ApplicationInstance.fromJS(item));
            }
            if (Array.isArray(_data["Pipelines"])) {
                this.pipelines = [] as any;
                for (let item of _data["Pipelines"])
                    this.pipelines!.push(ApplicationPipeline.fromJS(item));
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Application {
        data = typeof data === 'object' ? data : {};
        let result = new Application();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Version"] = this.version;
        data["Description"] = this.description;
        data["Owner"] = this.owner;
        data["Notes"] = this.notes;
        data["Framework"] = this.framework;
        data["RepositoryUri"] = this.repositoryUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        if (Array.isArray(this.instances)) {
            data["Instances"] = [];
            for (let item of this.instances)
                data["Instances"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.pipelines)) {
            data["Pipelines"] = [];
            for (let item of this.pipelines)
                data["Pipelines"].push(item ? item.toJSON() : undefined as any);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IApplication {
    id?: string;
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    tagIds?: string[] | undefined;
    instances?: ApplicationInstance[] | undefined;
    pipelines?: ApplicationPipeline[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class ApplicationInstance implements IApplicationInstance {
    id?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    dependencies?: ApplicationInstanceDependency[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IApplicationInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.baseUri = _data["BaseUri"];
            this.healthUri = _data["HealthUri"];
            this.openApiUri = _data["OpenApiUri"];
            this.version = _data["Version"];
            if (Array.isArray(_data["Dependencies"])) {
                this.dependencies = [] as any;
                for (let item of _data["Dependencies"])
                    this.dependencies!.push(ApplicationInstanceDependency.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ApplicationInstance {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["BaseUri"] = this.baseUri;
        data["HealthUri"] = this.healthUri;
        data["OpenApiUri"] = this.openApiUri;
        data["Version"] = this.version;
        if (Array.isArray(this.dependencies)) {
            data["Dependencies"] = [];
            for (let item of this.dependencies)
                data["Dependencies"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IApplicationInstance {
    id?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    dependencies?: ApplicationInstanceDependency[] | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class ApplicationInstanceDependency implements IApplicationInstanceDependency {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    accountId?: string | undefined;

    constructor(data?: IApplicationInstanceDependency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.port = _data["Port"];
            this.accountId = _data["AccountId"];
        }
    }

    static fromJS(data: any): ApplicationInstanceDependency {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInstanceDependency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["Port"] = this.port;
        data["AccountId"] = this.accountId;
        return data;
    }
}

export interface IApplicationInstanceDependency {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    accountId?: string | undefined;
}

export class ApplicationPipeline implements IApplicationPipeline {
    id?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;

    constructor(data?: IApplicationPipeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.pipelineUri = _data["PipelineUri"];
        }
    }

    static fromJS(data: any): ApplicationPipeline {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationPipeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["PipelineUri"] = this.pipelineUri;
        return data;
    }
}

export interface IApplicationPipeline {
    id?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;
}

export enum AuthKind {
    None = "None",
    UserPassword = "UserPassword",
    ApiKey = "ApiKey",
    BearerToken = "BearerToken",
    OAuthClient = "OAuthClient",
    ManagedIdentity = "ManagedIdentity",
    Certificate = "Certificate",
    Other = "Other",
}

export class CreateAccount implements ICreateAccount {
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretRef?: string | undefined;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.authKind = _data["AuthKind"];
            this.secretRef = _data["SecretRef"];
            this.userName = _data["UserName"];
            if (_data["Parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["Parameters"]) {
                    if (_data["Parameters"].hasOwnProperty(key))
                        (this.parameters as any)![key] = _data["Parameters"][key];
                }
            }
            if (Array.isArray(_data["Grants"])) {
                this.grants = [] as any;
                for (let item of _data["Grants"])
                    this.grants!.push(Grant.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAccount {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["AuthKind"] = this.authKind;
        data["SecretRef"] = this.secretRef;
        data["UserName"] = this.userName;
        if (this.parameters) {
            data["Parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (data["Parameters"] as any)[key] = (this.parameters as any)[key];
            }
        }
        if (Array.isArray(this.grants)) {
            data["Grants"] = [];
            for (let item of this.grants)
                data["Grants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateAccount {
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretRef?: string | undefined;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;
}

export class CreateAccountGrant implements ICreateAccountGrant {
    accountId?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;

    constructor(data?: ICreateAccountGrant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            if (Array.isArray(_data["Privileges"])) {
                this.privileges = [] as any;
                for (let item of _data["Privileges"])
                    this.privileges!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateAccountGrant {
        data = typeof data === 'object' ? data : {};
        let result = new CreateAccountGrant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        if (Array.isArray(this.privileges)) {
            data["Privileges"] = [];
            for (let item of this.privileges)
                data["Privileges"].push(item);
        }
        return data;
    }
}

export interface ICreateAccountGrant {
    accountId?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;
}

export class CreateApplication implements ICreateApplication {
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.version = _data["Version"];
            this.description = _data["Description"];
            this.owner = _data["Owner"];
            this.notes = _data["Notes"];
            this.framework = _data["Framework"];
            this.repositoryUri = _data["RepositoryUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateApplication {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Version"] = this.version;
        data["Description"] = this.description;
        data["Owner"] = this.owner;
        data["Notes"] = this.notes;
        data["Framework"] = this.framework;
        data["RepositoryUri"] = this.repositoryUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateApplication {
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateApplicationDependency implements ICreateApplicationDependency {
    applicationId?: string;
    instanceId?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    accountId?: string | undefined;

    constructor(data?: ICreateApplicationDependency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.instanceId = _data["InstanceId"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.port = _data["Port"];
            this.accountId = _data["AccountId"];
        }
    }

    static fromJS(data: any): CreateApplicationDependency {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationDependency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["InstanceId"] = this.instanceId;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["Port"] = this.port;
        data["AccountId"] = this.accountId;
        return data;
    }
}

export interface ICreateApplicationDependency {
    applicationId?: string;
    instanceId?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    accountId?: string | undefined;
}

export class CreateApplicationInstance implements ICreateApplicationInstance {
    applicationId?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateApplicationInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.baseUri = _data["BaseUri"];
            this.healthUri = _data["HealthUri"];
            this.openApiUri = _data["OpenApiUri"];
            this.version = _data["Version"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateApplicationInstance {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["BaseUri"] = this.baseUri;
        data["HealthUri"] = this.healthUri;
        data["OpenApiUri"] = this.openApiUri;
        data["Version"] = this.version;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateApplicationInstance {
    applicationId?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateApplicationPipeline implements ICreateApplicationPipeline {
    applicationId?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;

    constructor(data?: ICreateApplicationPipeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.name = _data["Name"];
            this.pipelineUri = _data["PipelineUri"];
        }
    }

    static fromJS(data: any): CreateApplicationPipeline {
        data = typeof data === 'object' ? data : {};
        let result = new CreateApplicationPipeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["Name"] = this.name;
        data["PipelineUri"] = this.pipelineUri;
        return data;
    }
}

export interface ICreateApplicationPipeline {
    applicationId?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;
}

export class CreateDataStore implements ICreateDataStore {
    name?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateDataStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.kind = _data["Kind"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.connectionUri = _data["ConnectionUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateDataStore {
        data = typeof data === 'object' ? data : {};
        let result = new CreateDataStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Kind"] = this.kind;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["ConnectionUri"] = this.connectionUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateDataStore {
    name?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateEnvironment implements ICreateEnvironment {
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;

    constructor(data?: ICreateEnvironment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.description = _data["Description"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.autoCreateInstances = _data["AutoCreateInstances"];
            this.baseUriTemplate = _data["BaseUriTemplate"];
            this.healthUriTemplate = _data["HealthUriTemplate"];
            this.openApiUriTemplate = _data["OpenApiUriTemplate"];
        }
    }

    static fromJS(data: any): CreateEnvironment {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEnvironment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Description"] = this.description;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["AutoCreateInstances"] = this.autoCreateInstances;
        data["BaseUriTemplate"] = this.baseUriTemplate;
        data["HealthUriTemplate"] = this.healthUriTemplate;
        data["OpenApiUriTemplate"] = this.openApiUriTemplate;
        return data;
    }
}

export interface ICreateEnvironment {
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;
}

export class CreateExternalResource implements ICreateExternalResource {
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreateExternalResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.resourceUri = _data["ResourceUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateExternalResource {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExternalResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["ResourceUri"] = this.resourceUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreateExternalResource {
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateKumaIntegration implements ICreateKumaIntegration {
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    apiKey?: string | undefined;

    constructor(data?: ICreateKumaIntegration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            if (Array.isArray(_data["EnvironmentIds"])) {
                this.environmentIds = [] as any;
                for (let item of _data["EnvironmentIds"])
                    this.environmentIds!.push(item);
            }
            this.platformId = _data["PlatformId"];
            this.accountId = _data["AccountId"];
            this.uri = _data["Uri"];
            this.apiKey = _data["ApiKey"];
        }
    }

    static fromJS(data: any): CreateKumaIntegration {
        data = typeof data === 'object' ? data : {};
        let result = new CreateKumaIntegration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        if (Array.isArray(this.environmentIds)) {
            data["EnvironmentIds"] = [];
            for (let item of this.environmentIds)
                data["EnvironmentIds"].push(item);
        }
        data["PlatformId"] = this.platformId;
        data["AccountId"] = this.accountId;
        data["Uri"] = this.uri;
        data["ApiKey"] = this.apiKey;
        return data;
    }
}

export interface ICreateKumaIntegration {
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    apiKey?: string | undefined;
}

export class CreatePlatform implements ICreatePlatform {
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: ICreatePlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["DisplayName"];
            this.dnsName = _data["DnsName"];
            this.os = _data["Os"];
            this.kind = _data["Kind"];
            this.ipAddress = _data["IpAddress"];
            this.notes = _data["Notes"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): CreatePlatform {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePlatform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DisplayName"] = this.displayName;
        data["DnsName"] = this.dnsName;
        data["Os"] = this.os;
        data["Kind"] = this.kind;
        data["IpAddress"] = this.ipAddress;
        data["Notes"] = this.notes;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface ICreatePlatform {
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;
}

export class CreateSecurityUser implements ICreateSecurityUser {
    userName?: string | undefined;
    password?: string | undefined;
    role?: SecurityRole;
    requestedBy?: string | undefined;

    constructor(data?: ICreateSecurityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            this.password = _data["Password"];
            this.role = _data["Role"];
            this.requestedBy = _data["RequestedBy"];
        }
    }

    static fromJS(data: any): CreateSecurityUser {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSecurityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        data["Role"] = this.role;
        data["RequestedBy"] = this.requestedBy;
        return data;
    }
}

export interface ICreateSecurityUser {
    userName?: string | undefined;
    password?: string | undefined;
    role?: SecurityRole;
    requestedBy?: string | undefined;
}

export class CreateTag implements ICreateTag {
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;

    constructor(data?: ICreateTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.color = _data["Color"];
        }
    }

    static fromJS(data: any): CreateTag {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Color"] = this.color;
        return data;
    }
}

export interface ICreateTag {
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;
}

export class DataStore implements IDataStore {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IDataStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.kind = _data["Kind"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.connectionUri = _data["ConnectionUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): DataStore {
        data = typeof data === 'object' ? data : {};
        let result = new DataStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Kind"] = this.kind;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["ConnectionUri"] = this.connectionUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IDataStore {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class EnvironmentInfo implements IEnvironmentInfo {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;

    constructor(data?: IEnvironmentInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.autoCreateInstances = _data["AutoCreateInstances"];
            this.baseUriTemplate = _data["BaseUriTemplate"];
            this.healthUriTemplate = _data["HealthUriTemplate"];
            this.openApiUriTemplate = _data["OpenApiUriTemplate"];
        }
    }

    static fromJS(data: any): EnvironmentInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EnvironmentInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["AutoCreateInstances"] = this.autoCreateInstances;
        data["BaseUriTemplate"] = this.baseUriTemplate;
        data["HealthUriTemplate"] = this.healthUriTemplate;
        data["OpenApiUriTemplate"] = this.openApiUriTemplate;
        return data;
    }
}

export interface IEnvironmentInfo {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;
}

export class ExternalResource implements IExternalResource {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IExternalResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.resourceUri = _data["ResourceUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): ExternalResource {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["ResourceUri"] = this.resourceUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IExternalResource {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class Grant implements IGrant {
    id?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;

    constructor(data?: IGrant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            if (Array.isArray(_data["Privileges"])) {
                this.privileges = [] as any;
                for (let item of _data["Privileges"])
                    this.privileges!.push(item);
            }
        }
    }

    static fromJS(data: any): Grant {
        data = typeof data === 'object' ? data : {};
        let result = new Grant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        if (Array.isArray(this.privileges)) {
            data["Privileges"] = [];
            for (let item of this.privileges)
                data["Privileges"].push(item);
        }
        return data;
    }
}

export interface IGrant {
    id?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;
}

export class KumaIntegrationResponse implements IKumaIntegrationResponse {
    id?: string;
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IKumaIntegrationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            if (Array.isArray(_data["EnvironmentIds"])) {
                this.environmentIds = [] as any;
                for (let item of _data["EnvironmentIds"])
                    this.environmentIds!.push(item);
            }
            this.platformId = _data["PlatformId"];
            this.accountId = _data["AccountId"];
            this.uri = _data["Uri"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): KumaIntegrationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new KumaIntegrationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        if (Array.isArray(this.environmentIds)) {
            data["EnvironmentIds"] = [];
            for (let item of this.environmentIds)
                data["EnvironmentIds"].push(item);
        }
        data["PlatformId"] = this.platformId;
        data["AccountId"] = this.accountId;
        data["Uri"] = this.uri;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IKumaIntegrationResponse {
    id?: string;
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export class LoginSecurityUser implements ILoginSecurityUser {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginSecurityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["UserName"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): LoginSecurityUser {
        data = typeof data === 'object' ? data : {};
        let result = new LoginSecurityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["UserName"] = this.userName;
        data["Password"] = this.password;
        return data;
    }
}

export interface ILoginSecurityUser {
    userName?: string | undefined;
    password?: string | undefined;
}

export class LoginSession implements ILoginSession {
    token?: string | undefined;
    expiresAt?: Date;
    user?: SecurityUserInfo;

    constructor(data?: ILoginSession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["Token"];
            this.expiresAt = _data["ExpiresAt"] ? new Date(_data["ExpiresAt"].toString()) : undefined as any;
            this.user = _data["User"] ? SecurityUserInfo.fromJS(_data["User"]) : undefined as any;
        }
    }

    static fromJS(data: any): LoginSession {
        data = typeof data === 'object' ? data : {};
        let result = new LoginSession();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Token"] = this.token;
        data["ExpiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : undefined as any;
        data["User"] = this.user ? this.user.toJSON() : undefined as any;
        return data;
    }
}

export interface ILoginSession {
    token?: string | undefined;
    expiresAt?: Date;
    user?: SecurityUserInfo;
}

export class LogoutSecurityUser implements ILogoutSecurityUser {
    token?: string | undefined;

    constructor(data?: ILogoutSecurityUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["Token"];
        }
    }

    static fromJS(data: any): LogoutSecurityUser {
        data = typeof data === 'object' ? data : {};
        let result = new LogoutSecurityUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Token"] = this.token;
        return data;
    }
}

export interface ILogoutSecurityUser {
    token?: string | undefined;
}

export class Platform implements IPlatform {
    id?: string;
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: IPlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.displayName = _data["DisplayName"];
            this.dnsName = _data["DnsName"];
            this.os = _data["Os"];
            this.kind = _data["Kind"];
            this.ipAddress = _data["IpAddress"];
            this.notes = _data["Notes"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): Platform {
        data = typeof data === 'object' ? data : {};
        let result = new Platform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DisplayName"] = this.displayName;
        data["DnsName"] = this.dnsName;
        data["Os"] = this.os;
        data["Kind"] = this.kind;
        data["IpAddress"] = this.ipAddress;
        data["Notes"] = this.notes;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface IPlatform {
    id?: string;
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;
    createdAt?: Date;
    updatedAt?: Date;
}

export enum PlatformKind {
    Server = "Server",
    Cluster = "Cluster",
    Serverless = "Serverless",
    ContainerHost = "ContainerHost",
}

export enum Privilege {
    Select = "Select",
    Insert = "Insert",
    Update = "Update",
    Delete = "Delete",
    Execute = "Execute",
    Connect = "Connect",
    Alter = "Alter",
    Control = "Control",
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    [key: string]: any;
}

export enum SecurityLevel {
    None = "None",
    RestrictedEditing = "RestrictedEditing",
    FullyRestricted = "FullyRestricted",
}

export enum SecurityRole {
    Reader = "Reader",
    Admin = "Admin",
}

export class SecuritySettings implements ISecuritySettings {
    level?: SecurityLevel;
    updatedAt?: Date;

    constructor(data?: ISecuritySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["Level"];
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecuritySettings {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Level"] = this.level;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecuritySettings {
    level?: SecurityLevel;
    updatedAt?: Date;
}

export class SecurityStateResponse implements ISecurityStateResponse {
    level?: SecurityLevel;
    updatedAt?: Date;
    requiresSetup?: boolean;
    hasUsers?: boolean;
    currentUser?: SecurityUserInfo;

    constructor(data?: ISecurityStateResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["Level"];
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
            this.requiresSetup = _data["RequiresSetup"];
            this.hasUsers = _data["HasUsers"];
            this.currentUser = _data["CurrentUser"] ? SecurityUserInfo.fromJS(_data["CurrentUser"]) : undefined as any;
        }
    }

    static fromJS(data: any): SecurityStateResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityStateResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Level"] = this.level;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        data["RequiresSetup"] = this.requiresSetup;
        data["HasUsers"] = this.hasUsers;
        data["CurrentUser"] = this.currentUser ? this.currentUser.toJSON() : undefined as any;
        return data;
    }
}

export interface ISecurityStateResponse {
    level?: SecurityLevel;
    updatedAt?: Date;
    requiresSetup?: boolean;
    hasUsers?: boolean;
    currentUser?: SecurityUserInfo;
}

export class SecurityUserInfo implements ISecurityUserInfo {
    id?: string;
    userName?: string | undefined;
    role?: SecurityRole;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ISecurityUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.role = _data["Role"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecurityUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["Role"] = this.role;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecurityUserInfo {
    id?: string;
    userName?: string | undefined;
    role?: SecurityRole;
    createdAt?: Date;
    updatedAt?: Date;
}

export class SecurityUserResponse implements ISecurityUserResponse {
    id?: string;
    userName?: string | undefined;
    role?: SecurityRole;
    createdAt?: Date;
    updatedAt?: Date;

    constructor(data?: ISecurityUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.userName = _data["UserName"];
            this.role = _data["Role"];
            this.createdAt = _data["CreatedAt"] ? new Date(_data["CreatedAt"].toString()) : undefined as any;
            this.updatedAt = _data["UpdatedAt"] ? new Date(_data["UpdatedAt"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): SecurityUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SecurityUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["UserName"] = this.userName;
        data["Role"] = this.role;
        data["CreatedAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["UpdatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : undefined as any;
        return data;
    }
}

export interface ISecurityUserResponse {
    id?: string;
    userName?: string | undefined;
    role?: SecurityRole;
    createdAt?: Date;
    updatedAt?: Date;
}

export class Tag implements ITag {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;

    constructor(data?: ITag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.color = _data["Color"];
        }
    }

    static fromJS(data: any): Tag {
        data = typeof data === 'object' ? data : {};
        let result = new Tag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Color"] = this.color;
        return data;
    }
}

export interface ITag {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;
}

export enum TagColor {
    Red = "Red",
    Green = "Green",
    Blue = "Blue",
    Yellow = "Yellow",
    Purple = "Purple",
    Orange = "Orange",
    Teal = "Teal",
    Gray = "Gray",
}

export enum TargetKind {
    Application = "Application",
    DataStore = "DataStore",
    External = "External",
}

export class UpdateAccount implements IUpdateAccount {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretRef?: string | undefined;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.authKind = _data["AuthKind"];
            this.secretRef = _data["SecretRef"];
            this.userName = _data["UserName"];
            if (_data["Parameters"]) {
                this.parameters = {} as any;
                for (let key in _data["Parameters"]) {
                    if (_data["Parameters"].hasOwnProperty(key))
                        (this.parameters as any)![key] = _data["Parameters"][key];
                }
            }
            if (Array.isArray(_data["Grants"])) {
                this.grants = [] as any;
                for (let item of _data["Grants"])
                    this.grants!.push(Grant.fromJS(item));
            }
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateAccount {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["AuthKind"] = this.authKind;
        data["SecretRef"] = this.secretRef;
        data["UserName"] = this.userName;
        if (this.parameters) {
            data["Parameters"] = {};
            for (let key in this.parameters) {
                if (this.parameters.hasOwnProperty(key))
                    (data["Parameters"] as any)[key] = (this.parameters as any)[key];
            }
        }
        if (Array.isArray(this.grants)) {
            data["Grants"] = [];
            for (let item of this.grants)
                data["Grants"].push(item ? item.toJSON() : undefined as any);
        }
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateAccount {
    id?: string;
    targetId?: string;
    targetKind?: TargetKind;
    authKind?: AuthKind;
    secretRef?: string | undefined;
    userName?: string | undefined;
    parameters?: { [key: string]: string; } | undefined;
    grants?: Grant[] | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateAccountGrant implements IUpdateAccountGrant {
    accountId?: string;
    grantId?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;

    constructor(data?: IUpdateAccountGrant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accountId = _data["AccountId"];
            this.grantId = _data["GrantId"];
            this.database = _data["Database"];
            this.schema = _data["Schema"];
            if (Array.isArray(_data["Privileges"])) {
                this.privileges = [] as any;
                for (let item of _data["Privileges"])
                    this.privileges!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateAccountGrant {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAccountGrant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccountId"] = this.accountId;
        data["GrantId"] = this.grantId;
        data["Database"] = this.database;
        data["Schema"] = this.schema;
        if (Array.isArray(this.privileges)) {
            data["Privileges"] = [];
            for (let item of this.privileges)
                data["Privileges"].push(item);
        }
        return data;
    }
}

export interface IUpdateAccountGrant {
    accountId?: string;
    grantId?: string;
    database?: string | undefined;
    schema?: string | undefined;
    privileges?: Privilege[] | undefined;
}

export class UpdateApplication implements IUpdateApplication {
    id?: string;
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateApplication) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.version = _data["Version"];
            this.description = _data["Description"];
            this.owner = _data["Owner"];
            this.notes = _data["Notes"];
            this.framework = _data["Framework"];
            this.repositoryUri = _data["RepositoryUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateApplication {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplication();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Version"] = this.version;
        data["Description"] = this.description;
        data["Owner"] = this.owner;
        data["Notes"] = this.notes;
        data["Framework"] = this.framework;
        data["RepositoryUri"] = this.repositoryUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateApplication {
    id?: string;
    name?: string | undefined;
    version?: string | undefined;
    description?: string | undefined;
    owner?: string | undefined;
    notes?: string | undefined;
    framework?: string | undefined;
    repositoryUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateApplicationDependency implements IUpdateApplicationDependency {
    applicationId?: string;
    instanceId?: string;
    dependencyId?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    accountId?: string | undefined;

    constructor(data?: IUpdateApplicationDependency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.instanceId = _data["InstanceId"];
            this.dependencyId = _data["DependencyId"];
            this.targetId = _data["TargetId"];
            this.targetKind = _data["TargetKind"];
            this.port = _data["Port"];
            this.accountId = _data["AccountId"];
        }
    }

    static fromJS(data: any): UpdateApplicationDependency {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationDependency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["InstanceId"] = this.instanceId;
        data["DependencyId"] = this.dependencyId;
        data["TargetId"] = this.targetId;
        data["TargetKind"] = this.targetKind;
        data["Port"] = this.port;
        data["AccountId"] = this.accountId;
        return data;
    }
}

export interface IUpdateApplicationDependency {
    applicationId?: string;
    instanceId?: string;
    dependencyId?: string;
    targetId?: string;
    targetKind?: TargetKind;
    port?: number | undefined;
    accountId?: string | undefined;
}

export class UpdateApplicationInstance implements IUpdateApplicationInstance {
    applicationId?: string;
    instanceId?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateApplicationInstance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.instanceId = _data["InstanceId"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.baseUri = _data["BaseUri"];
            this.healthUri = _data["HealthUri"];
            this.openApiUri = _data["OpenApiUri"];
            this.version = _data["Version"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateApplicationInstance {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationInstance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["InstanceId"] = this.instanceId;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["BaseUri"] = this.baseUri;
        data["HealthUri"] = this.healthUri;
        data["OpenApiUri"] = this.openApiUri;
        data["Version"] = this.version;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateApplicationInstance {
    applicationId?: string;
    instanceId?: string;
    environmentId?: string;
    platformId?: string | undefined;
    baseUri?: string | undefined;
    healthUri?: string | undefined;
    openApiUri?: string | undefined;
    version?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateApplicationPipeline implements IUpdateApplicationPipeline {
    applicationId?: string;
    pipelineId?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;

    constructor(data?: IUpdateApplicationPipeline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.applicationId = _data["ApplicationId"];
            this.pipelineId = _data["PipelineId"];
            this.name = _data["Name"];
            this.pipelineUri = _data["PipelineUri"];
        }
    }

    static fromJS(data: any): UpdateApplicationPipeline {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateApplicationPipeline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ApplicationId"] = this.applicationId;
        data["PipelineId"] = this.pipelineId;
        data["Name"] = this.name;
        data["PipelineUri"] = this.pipelineUri;
        return data;
    }
}

export interface IUpdateApplicationPipeline {
    applicationId?: string;
    pipelineId?: string;
    name?: string | undefined;
    pipelineUri?: string | undefined;
}

export class UpdateDataStore implements IUpdateDataStore {
    id?: string;
    name?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateDataStore) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.kind = _data["Kind"];
            this.environmentId = _data["EnvironmentId"];
            this.platformId = _data["PlatformId"];
            this.connectionUri = _data["ConnectionUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateDataStore {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDataStore();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Kind"] = this.kind;
        data["EnvironmentId"] = this.environmentId;
        data["PlatformId"] = this.platformId;
        data["ConnectionUri"] = this.connectionUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateDataStore {
    id?: string;
    name?: string | undefined;
    kind?: string | undefined;
    environmentId?: string;
    platformId?: string | undefined;
    connectionUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateEnvironment implements IUpdateEnvironment {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;

    constructor(data?: IUpdateEnvironment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
            this.autoCreateInstances = _data["AutoCreateInstances"];
            this.baseUriTemplate = _data["BaseUriTemplate"];
            this.healthUriTemplate = _data["HealthUriTemplate"];
            this.openApiUriTemplate = _data["OpenApiUriTemplate"];
        }
    }

    static fromJS(data: any): UpdateEnvironment {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEnvironment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        data["AutoCreateInstances"] = this.autoCreateInstances;
        data["BaseUriTemplate"] = this.baseUriTemplate;
        data["HealthUriTemplate"] = this.healthUriTemplate;
        data["OpenApiUriTemplate"] = this.openApiUriTemplate;
        return data;
    }
}

export interface IUpdateEnvironment {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    tagIds?: string[] | undefined;
    autoCreateInstances?: boolean;
    baseUriTemplate?: string | undefined;
    healthUriTemplate?: string | undefined;
    openApiUriTemplate?: string | undefined;
}

export class ApplyEnvironmentAutomation implements IApplyEnvironmentAutomation {
    environmentId?: string | undefined;
    applicationId?: string | undefined;

    constructor(data?: IApplyEnvironmentAutomation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.environmentId = _data["EnvironmentId"];
            this.applicationId = _data["ApplicationId"];
        }
    }

    static fromJS(data: any): ApplyEnvironmentAutomation {
        data = typeof data === 'object' ? data : {};
        let result = new ApplyEnvironmentAutomation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["EnvironmentId"] = this.environmentId;
        data["ApplicationId"] = this.applicationId;
        return data;
    }
}

export interface IApplyEnvironmentAutomation {
    environmentId?: string | undefined;
    applicationId?: string | undefined;
}

export class UpdateExternalResource implements IUpdateExternalResource {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdateExternalResource) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.resourceUri = _data["ResourceUri"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateExternalResource {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExternalResource();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["ResourceUri"] = this.resourceUri;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdateExternalResource {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    resourceUri?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateKumaIntegration implements IUpdateKumaIntegration {
    id?: string;
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    apiKey?: string | undefined;

    constructor(data?: IUpdateKumaIntegration) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            if (Array.isArray(_data["EnvironmentIds"])) {
                this.environmentIds = [] as any;
                for (let item of _data["EnvironmentIds"])
                    this.environmentIds!.push(item);
            }
            this.platformId = _data["PlatformId"];
            this.accountId = _data["AccountId"];
            this.uri = _data["Uri"];
            this.apiKey = _data["ApiKey"];
        }
    }

    static fromJS(data: any): UpdateKumaIntegration {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateKumaIntegration();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        if (Array.isArray(this.environmentIds)) {
            data["EnvironmentIds"] = [];
            for (let item of this.environmentIds)
                data["EnvironmentIds"].push(item);
        }
        data["PlatformId"] = this.platformId;
        data["AccountId"] = this.accountId;
        data["Uri"] = this.uri;
        data["ApiKey"] = this.apiKey;
        return data;
    }
}

export interface IUpdateKumaIntegration {
    id?: string;
    name?: string | undefined;
    environmentIds?: string[] | undefined;
    platformId?: string | undefined;
    accountId?: string | undefined;
    uri?: string | undefined;
    apiKey?: string | undefined;
}

export class UpdatePlatform implements IUpdatePlatform {
    id?: string;
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;

    constructor(data?: IUpdatePlatform) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.displayName = _data["DisplayName"];
            this.dnsName = _data["DnsName"];
            this.os = _data["Os"];
            this.kind = _data["Kind"];
            this.ipAddress = _data["IpAddress"];
            this.notes = _data["Notes"];
            if (Array.isArray(_data["TagIds"])) {
                this.tagIds = [] as any;
                for (let item of _data["TagIds"])
                    this.tagIds!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdatePlatform {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePlatform();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["DisplayName"] = this.displayName;
        data["DnsName"] = this.dnsName;
        data["Os"] = this.os;
        data["Kind"] = this.kind;
        data["IpAddress"] = this.ipAddress;
        data["Notes"] = this.notes;
        if (Array.isArray(this.tagIds)) {
            data["TagIds"] = [];
            for (let item of this.tagIds)
                data["TagIds"].push(item);
        }
        return data;
    }
}

export interface IUpdatePlatform {
    id?: string;
    displayName?: string | undefined;
    dnsName?: string | undefined;
    os?: string | undefined;
    kind?: PlatformKind;
    ipAddress?: string | undefined;
    notes?: string | undefined;
    tagIds?: string[] | undefined;
}

export class UpdateSecuritySettings implements IUpdateSecuritySettings {
    level?: SecurityLevel;
    requestedBy?: string | undefined;

    constructor(data?: IUpdateSecuritySettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["Level"];
            this.requestedBy = _data["RequestedBy"];
        }
    }

    static fromJS(data: any): UpdateSecuritySettings {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSecuritySettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Level"] = this.level;
        data["RequestedBy"] = this.requestedBy;
        return data;
    }
}

export interface IUpdateSecuritySettings {
    level?: SecurityLevel;
    requestedBy?: string | undefined;
}

export class UpdateTag implements IUpdateTag {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;

    constructor(data?: IUpdateTag) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.description = _data["Description"];
            this.color = _data["Color"];
        }
    }

    static fromJS(data: any): UpdateTag {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTag();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["Description"] = this.description;
        data["Color"] = this.color;
        return data;
    }
}

export interface IUpdateTag {
    id?: string;
    name?: string | undefined;
    description?: string | undefined;
    color?: TagColor;
}

export class UpdateUser implements IUpdateUser {
    id?: string;
    role?: SecurityRole;

    constructor(data?: IUpdateUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.role = _data["Role"];
        }
    }

    static fromJS(data: any): UpdateUser {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Role"] = this.role;
        return data;
    }
}

export interface IUpdateUser {
    id?: string;
    role?: SecurityRole;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}